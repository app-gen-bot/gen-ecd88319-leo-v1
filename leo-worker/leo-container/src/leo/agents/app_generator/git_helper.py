"""
Git Helper for App Generator Agent.

Handles automatic version control for generated applications.
"""

import logging
import subprocess
from pathlib import Path
from typing import Optional, List, Dict

logger = logging.getLogger(__name__)


class GitHelper:
    """Helper class for git operations on generated apps."""

    def __init__(self):
        """Initialize the Git Helper."""
        pass

    def initialize_repo(self, app_path: str) -> bool:
        """
        Initialize a git repository if one doesn't exist.

        Args:
            app_path: Path to the app directory

        Returns:
            True if repo was initialized, False if already exists
        """
        app_path = Path(app_path)
        git_dir = app_path / ".git"

        if git_dir.exists():
            logger.debug(f"Git repo already exists at {app_path}")
            return False

        try:
            # Initialize repo
            subprocess.run(
                ["git", "init"],
                cwd=app_path,
                check=True,
                capture_output=True,
                text=True
            )

            # Create .gitignore if it doesn't exist
            gitignore_path = app_path / ".gitignore"
            if not gitignore_path.exists():
                gitignore_content = """node_modules/
dist/
.env
.env.local
*.log
.DS_Store
"""
                gitignore_path.write_text(gitignore_content)

            logger.info(f"✅ Initialized git repo at {app_path}")
            return True

        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to initialize git repo: {e}")
            return False

    def has_uncommitted_changes(self, app_path: str) -> bool:
        """
        Check if there are uncommitted changes in the repo.

        Args:
            app_path: Path to the app directory

        Returns:
            True if there are uncommitted changes
        """
        try:
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                cwd=app_path,
                check=True,
                capture_output=True,
                text=True
            )
            # If output is not empty, there are changes
            return bool(result.stdout.strip())

        except subprocess.CalledProcessError:
            logger.warning(f"Could not check git status at {app_path}")
            return False

    def create_commit(
        self,
        app_path: str,
        message: str,
        description: Optional[str] = None
    ) -> Optional[str]:
        """
        Create a git commit with all changes.

        Args:
            app_path: Path to the app directory
            message: Commit summary (first line)
            description: Optional detailed description

        Returns:
            Commit hash if successful, None otherwise
        """
        try:
            # Stage all changes
            subprocess.run(
                ["git", "add", "-A"],
                cwd=app_path,
                check=True,
                capture_output=True
            )

            # Check if there's anything to commit
            if not self.has_uncommitted_changes(app_path):
                logger.debug("No changes to commit")
                return None

            # Build commit message
            commit_message = message
            if description:
                commit_message += f"\n\n{description}"

            commit_message += "\n\nGenerated by: App Generator Agent"

            # Create commit
            subprocess.run(
                ["git", "commit", "-m", commit_message],
                cwd=app_path,
                check=True,
                capture_output=True,
                text=True
            )

            # Get the commit hash
            result = subprocess.run(
                ["git", "rev-parse", "HEAD"],
                cwd=app_path,
                check=True,
                capture_output=True,
                text=True
            )
            commit_hash = result.stdout.strip()[:7]  # Short hash

            logger.info(f"✅ Created commit {commit_hash}: {message}")
            return commit_hash

        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to create commit: {e}")
            return None

    def get_commit_history(self, app_path: str, limit: int = 5) -> List[Dict[str, str]]:
        """
        Get recent commit history.

        Args:
            app_path: Path to the app directory
            limit: Maximum number of commits to return

        Returns:
            List of commit dicts with 'hash', 'message', 'author', 'date'
        """
        try:
            # Format: hash|message|author|date
            result = subprocess.run(
                [
                    "git", "log",
                    f"-{limit}",
                    "--pretty=format:%h|%s|%an|%ar"
                ],
                cwd=app_path,
                check=True,
                capture_output=True,
                text=True
            )

            commits = []
            for line in result.stdout.strip().split("\n"):
                if line:
                    parts = line.split("|", 3)
                    if len(parts) == 4:
                        commits.append({
                            "hash": parts[0],
                            "message": parts[1],
                            "author": parts[2],
                            "date": parts[3],
                        })

            return commits

        except subprocess.CalledProcessError:
            logger.warning(f"Could not get commit history at {app_path}")
            return []

    def get_last_commit_message(self, app_path: str) -> Optional[str]:
        """
        Get the last commit message.

        Args:
            app_path: Path to the app directory

        Returns:
            Last commit message or None
        """
        commits = self.get_commit_history(app_path, limit=1)
        return commits[0]["message"] if commits else None

    def create_initial_commit(self, app_path: str, app_name: str) -> Optional[str]:
        """
        Create the initial commit after app generation.

        Args:
            app_path: Path to the app directory
            app_name: Name of the app

        Returns:
            Commit hash if successful
        """
        message = f"feat: Initial generation of {app_name}"
        description = """Complete full-stack application generated with:
- Backend: Schema, contracts, auth, storage, routes
- Frontend: API client, auth context, pages, components
- Production-ready with factory patterns

Ready to run: npm install && npm run dev"""

        return self.create_commit(app_path, message, description)

    def create_checkpoint_commit(
        self,
        app_path: str,
        user_input: str,
        expanded_input: Optional[str] = None
    ) -> Optional[str]:
        """
        Create a checkpoint commit before modifications.

        Args:
            app_path: Path to the app directory
            user_input: Original user input
            expanded_input: Expanded instructions (if expansion happened)

        Returns:
            Commit hash if successful
        """
        message = f"chore: Pre-modification checkpoint"

        description = f'User requested: "{user_input}"'
        if expanded_input and expanded_input != user_input:
            description += f'\n\nExpanded to:\n{expanded_input[:200]}...'

        return self.create_commit(app_path, message, description)
