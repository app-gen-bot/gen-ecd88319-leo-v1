#!/usr/bin/env ts-node

/**
 * DynamoDB Seed Script for Slack Clone Application
 * 
 * This script creates all DynamoDB tables and populates them with
 * the seed data extracted from the frontend wireframe.
 * 
 * Usage:
 *   npm install -D ts-node @types/node aws-sdk
 *   export AWS_REGION=us-east-1
 *   export ENVIRONMENT=dev
 *   ts-node seed-dynamodb.ts
 * 
 * Or with npx:
 *   npx ts-node seed-dynamodb.ts --env=dev --region=us-east-1
 * 
 * Generated by: Integration Analyzer Tool
 * Date: 2025-06-29
 */

import { DynamoDB } from 'aws-sdk';
import { tableDefinitions, tableCreationOrder, getAllTableDefinitions } from './dynamodb-tables';
import { seedData } from './seed-data';

// Parse command line arguments
const args = process.argv.slice(2);
const getArg = (name: string, defaultValue?: string) => {
  const arg = args.find(a => a.startsWith(`--${name}=`));
  return arg ? arg.split('=')[1] : defaultValue;
};

// Configuration
const ENVIRONMENT = getArg('env', process.env.ENVIRONMENT || 'dev');
const AWS_REGION = getArg('region', process.env.AWS_REGION || 'us-east-1');
const SKIP_TABLE_CREATION = getArg('skip-tables', 'false') === 'true';
const SKIP_DATA_SEEDING = getArg('skip-data', 'false') === 'true';

// Initialize AWS SDK
const dynamodb = new DynamoDB({ region: AWS_REGION });
const docClient = new DynamoDB.DocumentClient({ region: AWS_REGION });

// Utility functions
const wait = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

async function tableExists(tableName: string): Promise<boolean> {
  try {
    await dynamodb.describeTable({ TableName: tableName }).promise();
    return true;
  } catch (error) {
    if ((error as any).code === 'ResourceNotFoundException') {
      return false;
    }
    throw error;
  }
}

async function waitForTable(tableName: string): Promise<void> {
  console.log(`â³ Waiting for table ${tableName} to become active...`);
  
  while (true) {
    const { Table } = await dynamodb.describeTable({ TableName: tableName }).promise();
    
    if (Table?.TableStatus === 'ACTIVE') {
      // Also check all GSIs are active
      const allGSIsActive = Table.GlobalSecondaryIndexes?.every(
        gsi => gsi.IndexStatus === 'ACTIVE'
      ) ?? true;
      
      if (allGSIsActive) {
        console.log(`âœ… Table ${tableName} is active`);
        break;
      }
    }
    
    await wait(2000);
  }
}

async function createTable(tableName: string): Promise<void> {
  const definition = (tableDefinitions as any)[tableName](ENVIRONMENT);
  
  if (await tableExists(definition.TableName)) {
    console.log(`âš ï¸  Table ${definition.TableName} already exists, skipping...`);
    return;
  }
  
  console.log(`ğŸ“¦ Creating table ${definition.TableName}...`);
  
  try {
    await dynamodb.createTable(definition).promise();
    await waitForTable(definition.TableName);
  } catch (error) {
    console.error(`âŒ Failed to create table ${definition.TableName}:`, error);
    throw error;
  }
}

async function batchWriteItems(tableName: string, items: any[]): Promise<void> {
  // DynamoDB batch write limit is 25 items
  const BATCH_SIZE = 25;
  
  for (let i = 0; i < items.length; i += BATCH_SIZE) {
    const batch = items.slice(i, i + BATCH_SIZE);
    
    const params: DynamoDB.DocumentClient.BatchWriteItemInput = {
      RequestItems: {
        [tableName]: batch.map(item => ({
          PutRequest: { Item: item }
        }))
      }
    };
    
    try {
      await docClient.batchWrite(params).promise();
      console.log(`  âœ“ Inserted ${batch.length} items (${i + batch.length}/${items.length})`);
    } catch (error) {
      console.error(`  âœ— Failed to insert batch:`, error);
      throw error;
    }
  }
}

async function seedTable(tableName: string, data: any[]): Promise<void> {
  if (!data || data.length === 0) {
    console.log(`âš ï¸  No data to seed for ${tableName}`);
    return;
  }
  
  console.log(`ğŸŒ± Seeding ${tableName} with ${data.length} items...`);
  await batchWriteItems(tableName, data);
  console.log(`âœ… Seeded ${tableName}`);
}

// Main seeding logic
async function createTables(): Promise<void> {
  console.log('\nğŸ—ï¸  Creating DynamoDB tables...\n');
  
  for (const tableName of tableCreationOrder) {
    await createTable(tableName);
  }
  
  console.log('\nâœ… All tables created successfully!\n');
}

async function seedAllData(): Promise<void> {
  console.log('\nğŸŒ± Seeding data into tables...\n');
  
  const getTableName = (base: string) => `slack-clone-${ENVIRONMENT}-${base}`;
  
  // Seed in dependency order
  
  // 1. Workspaces
  await seedTable(getTableName('workspaces'), seedData.workspaces);
  
  // 2. Users
  const usersWithWorkspace = seedData.users.map(user => ({
    ...user,
    workspaceId: 'ws-1' // Adding workspaceId for GSI
  }));
  await seedTable(getTableName('users'), usersWithWorkspace);
  
  // 3. Channels
  const channelsWithWorkspace = seedData.channels.map(channel => ({
    ...channel,
    workspaceId: 'ws-1' // Adding workspaceId for GSI
  }));
  await seedTable(getTableName('channels'), channelsWithWorkspace);
  
  // 4. Channel Memberships
  const membershipsWithTimestamp = seedData.channelMemberships.map(membership => ({
    ...membership,
    joinedAt: new Date().toISOString()
  }));
  await seedTable(getTableName('channel-memberships'), membershipsWithTimestamp);
  
  // 5. Conversations
  const conversationsWithWorkspace = seedData.conversations.map(conv => ({
    ...conv,
    workspaceId: 'ws-1' // Adding workspaceId for GSI
  }));
  await seedTable(getTableName('conversations'), conversationsWithWorkspace);
  
  // 6. Conversation Participants
  const conversationParticipants = seedData.conversations.flatMap(conv =>
    conv.participants.map(userId => ({
      conversationId: conv.id,
      userId,
      joinedAt: conv.createdAt
    }))
  );
  await seedTable(getTableName('conversation-participants'), conversationParticipants);
  
  // 7. Messages (both channel and DM)
  const allMessages = [
    ...seedData.messages,
    ...seedData.directMessages.map(dm => ({
      ...dm,
      channelId: dm.conversationId // Using conversationId as channelId for DMs
    }))
  ];
  await seedTable(getTableName('messages'), allMessages);
  
  // 8. Files
  const filesWithWorkspace = seedData.files.map(file => ({
    ...file,
    workspaceId: 'ws-1'
  }));
  await seedTable(getTableName('files'), filesWithWorkspace);
  
  // 9. Notifications
  const notificationsWithUser = seedData.notifications.map(notif => ({
    ...notif,
    userId: 'me', // Notifications for the current user
    timestamp: new Date().toISOString()
  }));
  await seedTable(getTableName('notifications'), notificationsWithUser);
  
  // 10. Presence
  const presenceData = seedData.users.map(user => ({
    userId: user.id,
    workspaceId: 'ws-1',
    status: user.status,
    lastSeen: new Date().toISOString(),
    ttl: Math.floor(Date.now() / 1000) + 3600 // TTL: 1 hour from now
  }));
  await seedTable(getTableName('presence'), presenceData);
  
  console.log('\nâœ… All data seeded successfully!\n');
}

// Main execution
async function main(): Promise<void> {
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           DynamoDB Seeding Script                     â•‘
â•‘                                                       â•‘
â•‘  Environment: ${ENVIRONMENT.padEnd(39)}â•‘
â•‘  Region:      ${AWS_REGION.padEnd(39)}â•‘
â•‘                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`);
  
  try {
    // Create tables if not skipped
    if (!SKIP_TABLE_CREATION) {
      await createTables();
    } else {
      console.log('âš ï¸  Skipping table creation (--skip-tables=true)');
    }
    
    // Seed data if not skipped
    if (!SKIP_DATA_SEEDING) {
      await seedAllData();
    } else {
      console.log('âš ï¸  Skipping data seeding (--skip-data=true)');
    }
    
    // Print summary
    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    Summary                            â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  Tables Created:     ${tableCreationOrder.length.toString().padEnd(31)}â•‘
â•‘  Records Inserted:   ~${Object.values(seedData).reduce((acc, val) => {
  if (Array.isArray(val)) return acc + val.length;
  if (typeof val === 'object' && val !== null) return acc + 1;
  return acc;
}, 0).toString().padEnd(30)}â•‘
â•‘                                                       â•‘
â•‘  Next Steps:                                          â•‘
â•‘  1. Update API endpoints to use these tables          â•‘
â•‘  2. Configure IAM roles for Lambda functions          â•‘
â•‘  3. Set up DynamoDB streams for real-time features   â•‘
â•‘                                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`);
    
  } catch (error) {
    console.error('\nâŒ Seeding failed:', error);
    process.exit(1);
  }
}

// Run the script
if (require.main === module) {
  main().catch(console.error);
}

// Export for testing
export { createTables, seedAllData, main };