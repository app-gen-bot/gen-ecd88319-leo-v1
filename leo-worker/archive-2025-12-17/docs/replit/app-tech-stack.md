# Generated App Tech Stack

Concise overview of the opinionated technology stack and architecture patterns used in web applications generated by the agentic system.

## Frontend Stack

**Core Framework:**
- **React 18** with **TypeScript** - Component-based UI with full type safety
- **Vite** - Fast development server with instant HMR and optimized builds
- **Wouter** - Lightweight (2.8kb) client-side routing with hooks-based API

**Styling & Components:**
- **Tailwind CSS** - Utility-first styling with design system built-in
- **shadcn/UI** - Copy-paste component library built on Radix UI primitives
- **Responsive Design** - Mobile-first with accessibility compliance

**State Management:**
- **TanStack Query** - Server state management with caching and background refetching
- **React Built-in State** - Local UI state (useState, useReducer, useContext)
- **Form Handling** - react-hook-form with zodResolver for validation

**Key Benefits:**
- Massive ecosystem and developer pool
- Excellent dev tools and debugging experience
- Type safety across frontend/backend boundaries
- Professional design system out of the box

## Backend Stack

**Runtime & Framework:**
- **Node.js** with **TypeScript** - Same language for full-stack development
- **Express.js** - Mature, flexible web framework with rich middleware ecosystem
- **Single Process Architecture** - Frontend and backend run together on one port

**API Design:**
- **RESTful Endpoints** - Resource-oriented with clear HTTP method semantics
- **Schema-First Design** - Database schema drives API contracts and validation
- **Zod Validation** - Runtime type validation for all requests/responses

**Key Benefits:**
- Language unification across full stack
- Event-driven, non-blocking I/O for web applications
- Massive npm package ecosystem
- Simple deployment story on most platforms

## Database & ORM

**Database:**
- **PostgreSQL** - ACID compliance, complex queries, JSON support
- **Serverless Compatible** - Works with Neon, Supabase, and other providers

**ORM & Migrations:**
- **Drizzle ORM** - Type-safe SQL with minimal overhead
- **Migration Management** - Automated schema changes with drizzle-kit
- **Type Generation** - Automatic TypeScript types from database schema

**Storage Interface:**
- **IStorage Pattern** - Abstract interface for seamless development-to-production switch
- **MemStorage** - In-memory implementation for development
- **PostgresStorage** - Production implementation with one-line switch

**Key Benefits:**
- Type safety without code generation overhead
- SQL-like syntax with TypeScript integration
- Easy development-to-production migration

## Architecture Patterns

**File Organization:**
```
project/
├── shared/           # Types, schemas, utilities (both frontend/backend)
├── server/           # Backend: API routes, business logic, data access
├── client/           # Frontend: UI components, pages, state management  
├── migrations/       # Database migration files
└── config/           # Build tools, environment, deployment
```

**Development Server:**
- **Single Port (5000)** - API endpoints (/api/*) and frontend served together
- **Vite Middleware** - HMR and development features integrated into Express
- **No Proxy Configuration** - Simplified development setup

**API Contracts:**
- **shared/schema.ts** - Single source of truth for data models
- **Automatic Validation** - Zod schemas generated from database schema
- **Type Safety** - Full TypeScript coverage from database to UI

## Development Workflow

**Core Commands:**
```bash
npm run dev     # Development with HMR (NODE_ENV=development tsx server/index.ts)
npm run build   # Production build (Vite + esbuild)
npm run start   # Production server (node dist/index.js)
npm run db:push # Push schema to database (drizzle-kit push)
```

**Quality Gates:**
- TypeScript compilation passes without errors
- Server starts and responds to requests
- Frontend renders without console errors
- All API endpoints return correct data structures

**Development-to-Production Flow:**
1. Start with MemStorage for rapid development
2. Set DATABASE_URL environment variable
3. Run `npm run db:push` to create database schema
4. Change one line in `server/storage.ts` to switch to PostgresStorage
5. Restart application - now running with persistent database

## Security & Best Practices

**Environment Management:**
- All secrets managed via environment variables
- No sensitive data logged or committed to git
- Clear separation between development and production configs

**API Security:**
- Input validation with Zod schemas
- Helmet middleware for security headers
- CORS configuration
- SQL injection prevention through ORM

**Code Quality:**
- Full TypeScript coverage
- Consistent error handling patterns
- User-friendly error messages (no technical jargon)
- Accessibility compliance with semantic HTML

## Key Design Principles

**Schema-First Development:**
- Database schema defined first in shared/schema.ts
- API validation schemas generated automatically
- Frontend types inferred from backend contracts

**Progressive Enhancement:**
- Start with basic functionality working
- Add features incrementally while maintaining working state
- "Never broken" principle - always maintain compilable, runnable code

**User Experience Focus:**
- Plain language instead of technical jargon
- Loading states for all async operations
- Real-time validation with helpful feedback
- Mobile-responsive design required

**Enterprise Ready:**
- Team collaboration patterns
- Audit trails and logging
- Cost transparency for external services
- Security compliance considerations

---

This opinionated tech stack prioritizes developer productivity, type safety, and user experience while maintaining the flexibility to scale from simple prototypes to enterprise applications.