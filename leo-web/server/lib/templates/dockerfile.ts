/**
 * Dockerfile Template Generator for Generated Apps
 *
 * Creates production-ready Dockerfile for React + Express monolith apps.
 * Uses multi-stage builds to optimize image size and build time.
 */

export interface DockerfileOptions {
  appName: string;
  nodeVersion?: string;
  port?: number;
}

/**
 * Generate production-ready Dockerfile for a generated full-stack app
 *
 * Multi-stage build process:
 * 1. Frontend Builder - Compiles React/Vite frontend
 * 2. Backend Builder - Prepares production Node.js dependencies
 * 3. Production Runtime - Minimal final image with compiled code
 *
 * @param options - Configuration options
 * @returns Complete Dockerfile content
 */
export function generateDockerfile(options: DockerfileOptions): string {
  const {
    appName,
    nodeVersion = '20-alpine',
    port = 3000,
  } = options;

  return `# ============================================
# Multi-stage Dockerfile for ${appName}
# Generated by Leo AI App Generator
# ============================================

# Stage 1: Frontend Builder
# Compiles React/Vite frontend to static assets
FROM node:${nodeVersion} AS frontend-builder
WORKDIR /build

# Copy package files for dependency installation
COPY package*.json ./

# Install ALL dependencies (including devDependencies needed for build)
# Note: Using 'npm install' instead of 'npm ci' because generated apps may have
# out-of-sync package-lock.json due to dependency updates between generation and deployment.
# TODO: Fix in generator to run 'npm install --package-lock-only' after creating package.json
RUN npm install

# Copy frontend source code
COPY client ./client
COPY shared ./shared
COPY vite.config.ts ./vite.config.ts
COPY tsconfig.json ./tsconfig.json
COPY tsconfig.node.json ./tsconfig.node.json
COPY tailwind.config.js ./tailwind.config.js
COPY postcss.config.js ./postcss.config.js

# Build frontend - outputs to /build/dist
RUN npm run build

# Stage 2: Backend Builder
# Prepares production Node.js dependencies
FROM node:${nodeVersion} AS backend-builder
WORKDIR /build

# Copy package files
COPY package*.json ./

# Install ONLY production dependencies (excludes devDependencies)
# Note: Using 'npm install' instead of 'npm ci' for same reason as above
RUN npm install --omit=dev

# Stage 3: Production Runtime
# Final minimal image with compiled frontend + backend
FROM node:${nodeVersion}
WORKDIR /app

# Set PORT environment variable to match what Dockerfile/fly.toml expect
ENV PORT=${port}

# Copy production node_modules from backend-builder
COPY --from=backend-builder /build/node_modules ./node_modules

# Copy package.json for metadata and scripts
COPY package*.json ./

# Install tsx for running TypeScript in production
RUN npm install tsx

# Copy backend source code (TypeScript - will be run with tsx)
COPY server ./server
COPY shared ./shared
COPY tsconfig.json ./tsconfig.json
COPY tsconfig.*.json ./

# Copy compiled frontend from frontend-builder
COPY --from=frontend-builder /build/dist ./dist

# Create non-root user for security best practices
RUN addgroup --system --gid 1001 nodejs && \\
    adduser --system --uid 1001 nodeuser && \\
    chown -R nodeuser:nodejs /app

# Switch to non-root user
USER nodeuser

# Expose application port
EXPOSE ${port}

# Health check endpoint (assumes /health exists in backend)
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD node -e "require('http').get('http://localhost:${port}/health', (r) => { process.exit(r.statusCode === 200 ? 0 : 1) })"

# Start production server using tsx to run TypeScript directly
CMD ["npx", "tsx", "server/index.ts"]
`;
}

/**
 * Generate simple Dockerfile for static HTML apps (mock mode or simple generators)
 *
 * Uses nginx to serve static files - perfect for single-file apps
 *
 * @param options - Configuration options
 * @returns Complete Dockerfile content
 */
export function generateSimpleDockerfile(options: DockerfileOptions): string {
  const {
    appName,
    port = 8080,
  } = options;

  return `# ============================================
# Simple Static Dockerfile for ${appName}
# Generated by Leo AI App Generator
# ============================================

# Use nginx for serving static files
FROM nginx:alpine

# Copy all app files to nginx html directory
COPY . /usr/share/nginx/html/

# Expose the port
EXPOSE ${port}

# Create nginx config to listen on the specified port
RUN echo 'server { \
    listen ${port}; \
    location / { \
        root /usr/share/nginx/html; \
        index index.html; \
        try_files $uri $uri/ /index.html; \
    } \
}' > /etc/nginx/conf.d/default.conf

# Start nginx
CMD ["nginx", "-g", "daemon off;"]
`;
}

/**
 * Generate .dockerignore file to exclude unnecessary files from Docker build
 *
 * Excludes:
 * - Dependencies (installed during build)
 * - Test files
 * - Build artifacts (created during build)
 * - Local environment files (use secrets instead)
 * - IDE and system files
 *
 * @returns Complete .dockerignore file content
 */
export function generateDockerignore(): string {
  return `# Dependencies (installed during build)
node_modules
npm-debug.log
yarn-error.log
.pnp
.pnp.js
# Note: package-lock.json is NOT ignored - needed for npm ci

# Testing
coverage
.nyc_output
*.test.ts
*.test.tsx
*.test.js
*.test.jsx
*.spec.ts
*.spec.tsx
*.spec.js
*.spec.jsx
__tests__
test
tests

# Build artifacts (created during build)
dist
build
.cache
.vite
.turbo

# Environment files (use Fly.io secrets instead)
.env.local
.env.*.local
.env.development
.env.test

# IDE and editor files
.vscode
.idea
*.swp
*.swo
*.swn
.DS_Store
*.sublime-project
*.sublime-workspace

# Version control
.git
.gitignore
.gitattributes

# Documentation (keep README.md for GitHub)
*.md
!README.md
DEPLOYMENT.md
plan
docs

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# OS files
.DS_Store
Thumbs.db

# Temporary files
tmp
temp
*.tmp
`;
}
